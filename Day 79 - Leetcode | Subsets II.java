import java.util.*;

class Solution {

    // Approach:
    // 1. The function generates all possible subsets of the input array, including duplicates.
    // 2. The subsets are generated by recursively adding elements to a current subset and moving on to the next element.
    // 3. If we encounter a duplicate element (same as the previous one), we skip it to avoid generating duplicate subsets.
    // 4. The result is stored in a List of Lists.

    // Time Complexity (TC): O(2^n * n)
    // The number of subsets is 2^n, and for each subset, copying the list takes O(n) time.

    // Space Complexity (SC): O(2^n * n)
    // We store all subsets, and each subset can be up to size n.

    void f(List<List<Integer>> subsets, List<Integer> ds, int[] nums, int idx) {
        // Add the current subset to the list
        subsets.add(new ArrayList<>(ds));

        // Loop through the remaining elements to generate further subsets
        for (int i = idx; i < nums.length; i++) {
            // Skip duplicates to avoid generating the same subset
            if (i > idx && nums[i] == nums[i - 1]) continue;

            // Pick the current element
            ds.add(nums[i]);

            // Recursively call to explore further subsets
            f(subsets, ds, nums, i + 1);

            // Backtrack to explore other combinations
            ds.remove(ds.size() - 1);
        }
    }

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // Sort the array to ensure duplicates are adjacent
        Arrays.sort(nums);

        List<List<Integer>> subsets = new ArrayList<>();
        List<Integer> ds = new ArrayList<>();

        // Generate all subsets starting from index 0
        f(subsets, ds, nums, 0);

        return subsets;
    }
}
